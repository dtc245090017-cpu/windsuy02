<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Solar Black Glow (No-Module)</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#000}
    #hud{
      position:fixed;left:12px;top:12px;color:#fff;font:14px/1.45 system-ui,Segoe UI,Arial;
      background:rgba(0,0,0,.44);padding:10px 12px;border-radius:12px;
      user-select:none;max-width:520px
    }
    #hud kbd{background:rgba(255,255,255,.12);padding:2px 6px;border-radius:6px}
    #hud .small{opacity:.85;font-size:13px}
  </style>

  <!-- Three.js (global THREE) + OrbitControls bản non-module -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

  <!-- Epoch library (nếu load được thì dùng, không được sẽ fallback quỹ đạo tròn) -->
  <script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>
</head>
<body>
  <div id="hud">
    <b>Solar Black Glow (No-Module)</b><br/>
    Kéo: xoay • Lăn: zoom • Chuột phải: pan<br/>
    <span class="small">
      <kbd>Space</kbd> pause • <kbd>+</kbd>/<kbd>-</kbd> nhanh/chậm thời gian •
      <kbd>F</kbd> follow Sun • <kbd>T</kbd> trails<br/>
      <kbd>V</kbd> đổi “dọc” (nhiều kiểu) • <kbd>C</kbd> xóa trails • <kbd>R</kbd> reset camera
    </span>
  </div>

<script>
(() => {
  // ========== SETTINGS ==========
  const S = {
    exposure: 1.0,            // nền đen + sao rõ
    AU_TO_UNITS: 12.0,
    daysPerSecond: 18,

    sunSpeed: 1.9,
    sunWiggle: 0.22,
    followSunDefault: true,

    starCountFar: 110000,
    starCountNear: 45000,
    starSizeFar: 1.2,
    starSizeNear: 1.9,

    glowBodyCount: 9000,

    trails: true,
    trailPoints: 2600,
    trailOpacity: 0.32,
    trailEveryNFrames: 2,
  };

  // ========== Scene / Camera / Renderer ==========
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.01, 9000);
  camera.position.set(-40, 16, 92);

  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = S.exposure;
  document.body.appendChild(renderer.domElement);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.minDistance = 8;
  controls.maxDistance = 2600;

  window.addEventListener("resize", () => {
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // ========== Lights ==========
  scene.add(new THREE.AmbientLight(0xffffff, 0.14));
  const sunLight = new THREE.PointLight(0xfff2cc, 2.6, 0, 2);
  scene.add(sunLight);

  // ========== Stars (glow points) ==========
  function makeStarLayer(count, rMin, rMax, size, opacity){
    const pos = new Float32Array(count*3);
    const col = new Float32Array(count*3);
    const c = new THREE.Color();

    for(let i=0;i<count;i++){
      const r = THREE.MathUtils.randFloat(rMin, rMax);
      const th = Math.random()*Math.PI*2;
      const u  = THREE.MathUtils.randFloat(-1,1);
      const phi = Math.acos(u);

      pos[i*3+0] = r*Math.sin(phi)*Math.cos(th);
      pos[i*3+1] = r*Math.cos(phi);
      pos[i*3+2] = r*Math.sin(phi)*Math.sin(th);

      // màu sao hơi ngả xanh/vàng
      const hue = (Math.random()<0.75) ? THREE.MathUtils.randFloat(0.55, 0.70) : THREE.MathUtils.randFloat(0.08, 0.14);
      c.setHSL(hue % 1, THREE.MathUtils.randFloat(0.0,0.22), THREE.MathUtils.randFloat(0.78,1.0));
      col[i*3+0]=c.r; col[i*3+1]=c.g; col[i*3+2]=c.b;
    }

    const g = new THREE.BufferGeometry();
    g.setAttribute("position", new THREE.BufferAttribute(pos,3));
    g.setAttribute("color", new THREE.BufferAttribute(col,3));

    const m = new THREE.PointsMaterial({
      vertexColors:true,
      size,
      sizeAttenuation:true,
      transparent:true,
      opacity,
      blending: THREE.AdditiveBlending,
      depthWrite:false
    });

    const pts = new THREE.Points(g,m);
    scene.add(pts);
    return pts;
  }

  makeStarLayer(S.starCountFar, 500, 2600, S.starSizeFar, 0.55);
  makeStarLayer(S.starCountNear, 150, 1400, S.starSizeNear, 0.35);

  // ========== Extra glow bodies (như “đốm sáng”) ==========
  const glowGroup = new THREE.Group();
  scene.add(glowGroup);

  (function makeGlowBodies(){
    const count = S.glowBodyCount;
    const geo = new THREE.SphereGeometry(0.22, 10, 10);
    const mat = new THREE.MeshBasicMaterial({
      transparent:true,
      opacity:0.82,
      blending: THREE.AdditiveBlending,
      depthWrite:false
    });
    const inst = new THREE.InstancedMesh(geo, mat, count);

    const M4 = new THREE.Matrix4();
    const P = new THREE.Vector3();
    const Q = new THREE.Quaternion();
    const Sc = new THREE.Vector3();
    const c = new THREE.Color();

    for(let i=0;i<count;i++){
      const rr = THREE.MathUtils.randFloat(260, 2200);
      const th = Math.random()*Math.PI*2;
      const u  = THREE.MathUtils.randFloat(-1,1);
      const phi = Math.acos(u);

      P.set(rr*Math.sin(phi)*Math.cos(th), rr*Math.cos(phi), rr*Math.sin(phi)*Math.sin(th));
      const size = THREE.MathUtils.randFloat(0.10, 0.9);
      Sc.set(size,size,size);
      M4.compose(P,Q,Sc);
      inst.setMatrixAt(i,M4);

      c.setHSL(THREE.MathUtils.randFloat(0.55,0.78), THREE.MathUtils.randFloat(0.25,0.85), THREE.MathUtils.randFloat(0.62,0.95));
      inst.setColorAt(i,c);
    }
    inst.instanceColor.needsUpdate = true;
    glowGroup.add(inst);
  })();

  // ========== Sun + halo sprite (không chói) ==========
  const sun = new THREE.Mesh(
    new THREE.SphereGeometry(2.0, 64, 64),
    new THREE.MeshStandardMaterial({
      color: 0xffd36a,
      emissive: 0xffbf55,
      emissiveIntensity: 1.0,
      roughness: 1.0
    })
  );
  scene.add(sun);

  function makeHaloSprite(){
    const c = document.createElement("canvas");
    c.width = 256; c.height = 256;
    const ctx = c.getContext("2d");
    const g = ctx.createRadialGradient(128,128,18, 128,128,120);
    g.addColorStop(0, "rgba(255,235,175,0.30)");
    g.addColorStop(0.40, "rgba(255,210,120,0.12)");
    g.addColorStop(1, "rgba(255,200,80,0.0)");
    ctx.fillStyle = g; ctx.fillRect(0,0,256,256);

    const t = new THREE.CanvasTexture(c);
    t.colorSpace = THREE.SRGBColorSpace;
    const sp = new THREE.Sprite(new THREE.SpriteMaterial({
      map: t,
      transparent:true,
      depthWrite:false,
      blending: THREE.AdditiveBlending
    }));
    sp.scale.set(16,16,1);
    return sp;
  }

  const sunHalo = makeHaloSprite();
  scene.add(sunHalo);

  // ========== Vertical orbit modes ==========
  // 0 none, 1 rotate X90, 2 rotate Z90, 3 swap axes
  let vMode = 2;
  const qX90 = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), Math.PI/2);
  const qZ90 = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), Math.PI/2);

  function orient(v){
    if (vMode === 0) return v;
    if (vMode === 1) return v.applyQuaternion(qX90);
    if (vMode === 2) return v.applyQuaternion(qZ90);
    const x=v.x,y=v.y,z=v.z;
    v.set(x, z, -y);
    return v;
  }

  // ========== Planets (epoch nếu có, fallback nếu không) ==========
  const HAS_ASTRONOMY = typeof window.Astronomy !== "undefined";

  const planetDefs = [
    { key:"Mercury", r:0.35, color:0xbfbfbf },
    { key:"Venus",   r:0.55, color:0xffd1a1 },
    { key:"Earth",   r:0.60, color:0x66aaff },
    { key:"Mars",    r:0.45, color:0xff7a55 },
    { key:"Jupiter", r:1.25, color:0xffc48a },
    { key:"Saturn",  r:1.12, color:0xffe1a8, ring:true },
    { key:"Uranus",  r:0.92, color:0x9fe7ff },
    { key:"Neptune", r:0.92, color:0x5a88ff }
  ];

  function fallbackHelioAU(key, tDays){
    const auR = {
      Mercury:0.39, Venus:0.72, Earth:1.00, Mars:1.52,
      Jupiter:5.20, Saturn:9.58, Uranus:19.2, Neptune:30.05
    }[key] || 1.0;

    const period = {
      Mercury:88, Venus:225, Earth:365.25, Mars:687,
      Jupiter:4333, Saturn:10759, Uranus:30687, Neptune:60190
    }[key] || 365.25;

    const ang = (2*Math.PI/period)*tDays + key.length*0.7;
    return new THREE.Vector3(Math.cos(ang)*auR, 0, Math.sin(ang)*auR);
  }

  function epochHelioAU(key, date){
    const t = Astronomy.MakeTime(date);
    const body = Astronomy.Body[key];
    const v = Astronomy.HelioVector(body, t);
    return new THREE.Vector3(v.x, v.y, v.z);
  }

  // Trails
  function makeTrail(colorHex, maxPoints){
    const positions = new Float32Array(maxPoints*3);
    const geo = new THREE.BufferGeometry();
    geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    geo.setDrawRange(0,0);

    const mat = new THREE.LineBasicMaterial({
      color: colorHex,
      transparent:true,
      opacity: S.trailOpacity,
      blending: THREE.AdditiveBlending,
      depthWrite:false
    });

    const line = new THREE.Line(geo, mat);
    scene.add(line);

    return { positions, geo, maxPoints, ptr:0, count:0, line };
  }

  function pushTrail(tr, p){
    const i = tr.ptr;
    const b = i*3;
    tr.positions[b]=p.x; tr.positions[b+1]=p.y; tr.positions[b+2]=p.z;

    tr.ptr = (tr.ptr + 1) % tr.maxPoints;
    tr.count = Math.min(tr.count + 1, tr.maxPoints);
    tr.geo.attributes.position.needsUpdate = true;
    tr.geo.setDrawRange(0, tr.count);
  }

  function clearTrail(tr){
    tr.positions.fill(0);
    tr.ptr=0; tr.count=0;
    tr.geo.setDrawRange(0,0);
    tr.geo.attributes.position.needsUpdate = true;
  }

  const planets = [];
  for(const d of planetDefs){
    const mesh = new THREE.Mesh(
      new THREE.SphereGeometry(d.r, 40, 40),
      new THREE.MeshStandardMaterial({
        color: d.color,
        roughness: 1.0,
        emissive: 0x111111,
        emissiveIntensity: 0.22
      })
    );

    if (d.ring){
      const ring = new THREE.Mesh(
        new THREE.RingGeometry(d.r*1.25, d.r*2.05, 120),
        new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent:true,
          opacity: 0.35,
          side: THREE.DoubleSide,
          blending: THREE.AdditiveBlending,
          depthWrite:false
        })
      );
      ring.rotation.x = Math.PI/2;
      mesh.add(ring);
    }

    const trail = makeTrail(d.color, S.trailPoints);
    scene.add(mesh);
    planets.push({ ...d, mesh, trail });
  }

  // ========== Controls ==========
  let paused = false;
  let followSun = S.followSunDefault;
  let showTrails = S.trails;
  let daysPerSecond = S.daysPerSecond;

  function resetCamera(sunPos){
    camera.position.copy(sunPos).add(new THREE.Vector3(-40, 16, 92));
    controls.target.copy(sunPos);
    controls.update();
  }

  window.addEventListener("keydown", (e)=>{
    if (e.code === "Space") paused = !paused;
    if (e.key === "+" || e.key === "=") daysPerSecond *= 1.25;
    if (e.key === "-" || e.key === "_") daysPerSecond /= 1.25;
    if (e.key.toLowerCase() === "f") followSun = !followSun;
    if (e.key.toLowerCase() === "t") showTrails = !showTrails;
    if (e.key.toLowerCase() === "v") vMode = (vMode + 1) % 4;
    if (e.key.toLowerCase() === "c") for(const p of planets) clearTrail(p.trail);
    if (e.key.toLowerCase() === "r") resetCamera(sunPos);
  });

  // ========== Animate ==========
  const clock = new THREE.Clock();
  const epochStart = new Date();
  let simDays = 0;
  let frame = 0;

  const sunPos = new THREE.Vector3(0,0,0);
  resetCamera(sunPos);

  function animate(){
    requestAnimationFrame(animate);

    const dt = paused ? 0 : clock.getDelta();
    if (!paused) simDays += dt * daysPerSecond;

    // Sun moves forward + wiggle
    const dv = new THREE.Vector3(
      S.sunSpeed * dt,
      Math.sin(sunPos.x * 0.04) * S.sunWiggle * dt,
      Math.cos(sunPos.x * 0.03) * S.sunWiggle * dt
    );
    sunPos.add(dv);

    sun.position.copy(sunPos);
    sunHalo.position.copy(sunPos);
    sunLight.position.copy(sunPos);

    if (followSun){
      camera.position.add(dv);
      controls.target.add(dv);
    } else {
      controls.target.lerp(sunPos, 0.06);
    }

    // time
    const curDate = new Date(epochStart.getTime() + simDays*86400*1000);

    frame++;
    const updTrail = showTrails && (frame % S.trailEveryNFrames === 0);

    for(const p of planets){
      let au = HAS_ASTRONOMY ? epochHelioAU(p.key, curDate) : fallbackHelioAU(p.key, simDays);
      orient(au);
      au.multiplyScalar(S.AU_TO_UNITS);
      const world = au.add(sunPos);

      p.mesh.position.copy(world);
      p.mesh.rotation.y += dt*0.35;

      p.trail.line.visible = showTrails;
      if (updTrail) pushTrail(p.trail, world);
    }

    controls.update();
    renderer.render(scene, camera);
  }

  animate();
})();
</script>
</body>
</html>

